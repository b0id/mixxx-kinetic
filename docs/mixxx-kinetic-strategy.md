The Kinetic Fork: An Architectural Doctrine for Streaming Integration in Mixxx on EndeavourOS1. Executive Manifesto: The Doctrine of Kinetic Access1.1. The Shift from Ownership to AccessThe legacy of digital DJing is built upon the paradigm of static possession: the file on the hard drive. This model, characterized by low latency, high reliability, and absolute user control, has defined the architecture of Mixxx for over two decades. However, the contemporary landscape demands a shift from the Static Library to the Kinetic Library—a state where music is transient, accessed on-demand, and streamed in real-time. This document serves as the foundational doctrine for a dedicated fork of the Mixxx DJ software, tailored specifically for the rolling-release environment of EndeavourOS and the broader Arch Linux ecosystem. This fork, hereby referred to as "Mixxx-Kinetic," aims to integrate streaming capabilities from Beatport Link and Tidal, not as bolt-on plugins, but as first-class citizens within the mixing engine.The transition from a local-file paradigm to a streaming paradigm is not merely a feature addition; it is a fundamental inversion of the I/O hierarchy. In the static model, the disk is subservient to the processor; data is assumed to be available instantly. In the kinetic model, the processor is subservient to the network; data availability is probabilistic. The architecture proposed herein acknowledges this inversion. It rejects the naive approach of "streaming directly to the buffer" in favor of a robust, layered virtualization strategy that insulates the real-time audio engine from the inherent volatility of the wide area network.1.2. The Zero-Trust Stream PrincipleThe central tenet of this architectural doctrine is the Zero-Trust Stream Principle. In a live performance context, the network is strictly defined as a hostile entity. Latency spikes, packet loss, API rate limits, and silent authentication failures are not anomalies; they are expected operational states. Therefore, the architecture must never trust the stream to deliver audio data in real-time to the playback head.Instead, the system must employ an aggressive, multilayered virtualization strategy that presents remote streams to the Mixxx engine as if they were local, immutable files. This decoupling of network instability from engine rigidity is the only path to professional-grade reliability. We treat the network not as a source, but as a slow, unreliable disk drive that requires aggressive caching, read-ahead prefetching, and failure masking. The audio engine, running at real-time priority, should never handle a network socket directly.1.3. The Architectural Drift Prevention MandateTo prevent "architectural drift"—the gradual degradation of system cohesion caused by ad-hoc patches, loosely defined interfaces, and "it works on my machine" implementations—this report establishes a precise Source of Truth. We explicitly enumerate the APIs, C++ class structures, and data handling protocols required to bridge the proprietary worlds of Beatport and Tidal with the open-source rigor of Mixxx.This manifest serves as the rigid specification for the fork. It is not a suggestion; it is a compliance standard. Any deviation from the defined class hierarchies (e.g., SoundSourceProxy), database schemas (TrackDAO extensions), or API interaction flows (OAuth2 handling) constitutes a violation of the doctrine. This rigor is necessary because streaming services are volatile third parties; their APIs change without warning. By encapsulating these external dependencies in strictly defined "Hook" and "Bridge" components, we protect the core Mixxx codebase from external chaos.1.4. The Linux-First ImperativeTargeting EndeavourOS is a strategic, architectural decision, not merely a preference. It allows the architecture to leverage the latest kernel advances in asynchronous I/O (io_uring), modern audio subsystems (PipeWire), and the bleeding-edge dependency management of the Arch User Repository (AUR).This doctrine rejects the "lowest common denominator" approach of cross-platform compatibility (Windows/macOS) in favor of maximizing performance and maintainability on the Linux desktop. We utilize Linux-specific mechanisms, such as Filesystem in Userspace (FUSE) for transparent stream caching and Shared Memory segments for inter-process DRM handling, to bypass the limitations of generic cross-platform frameworks. EndeavourOS provides the ideal substrate: a minimal, performance-oriented environment where the user has granular control over system privileges, real-time scheduling, and kernel modules.2. Core Mixxx Architecture: The Fork State2.1. The Triad of StabilityMixxx’s current architecture relies on three critical components that govern the lifecycle of a track. Understanding these is essential for injecting streaming logic without destabilizing the application. The fork must respect these boundaries while extending their capabilities.2.1.1. TrackDAO (The Knowledge Base)The TrackDAO (Data Access Object) is the persistence layer. Currently, it assumes a track is a row in a SQLite database linked to a local filesystem path. It is the single source of truth for library metadata.Current State: It stores metadata (Artist, Title, BPM, Key) and a strictly local file path.1 Queries are optimized for local lookup.Kinetic Modification: The schema must be fundamentally extended. The concept of "location" must be abstracted. We introduce columns for remote_uri, service_provider (Beatport/Tidal), expiration_timestamp, drm_context, and offline_status. The location column, traditionally a filesystem path, must now serve a dual purpose: pointing to a persistent cache file if available, or a virtual mount point path (e.g., /run/user/1000/mixxx/beatport/123.mp3) if streaming.1 The DAO must also handle transient metadata—streaming links that expire after a set duration must not be permanently committed to the database in a way that implies longevity.2.1.2. SoundSource (The Decoder)SoundSource is the C++ abstract base class responsible for reading audio data from a file and decoding it into raw samples for the engine.Current State: Subclasses like SoundSourceSndFile, SoundSourceMP3, or SoundSourceFFmpeg open a file handle and read PCM data synchronously.4 They operate under the assumption that random access (seeking) is instantaneous and cost-free (effectively O(1) complexity).Kinetic Modification: We introduce a new hierarchy: SoundSourceProxy and SoundSourceStream. These classes must implement the SoundSource interface to satisfy the engine's compilation requirements but delegate the actual data retrieval to a Buffering Manager. Crucially, they must "fake" seekability to the engine. When the engine requests a seek to minute 3:00 of a track that hasn't downloaded yet, the SoundSourceStream must return silence (or a loop of the previous measure) while triggering a high-priority HTTP Range Request in the background. It must never block the audio thread while waiting for the network.62.1.3. EngineWorker (The Heartbeat)The EngineWorker processes audio in callback cycles (typically every 1-5ms). It is the most sensitive thread in the entire application.Current State: It pulls audio from the SoundSource via the CachingReader. If SoundSource blocks (e.g., waits for a spinning hard drive to wake up, or worse, a network packet), the audio buffer underruns, causing audible glitches (XRUNs).Kinetic Modification: The strict mandate is that SoundSourceStream must never perform network I/O or even filesystem I/O on the EngineWorker thread. All data retrieval logic must be offloaded to a dedicated StreamManager thread. The SoundSourceStream only reads from a lock-free ring buffer or a pre-mapped shared memory segment. If the buffer is empty, it outputs silence and signals a UI warning, but it preserves the integrity of the audio callback cycle.82.2. The Source of Truth: Essential C++ InterfacesTo maintain architectural integrity and prevent developers from taking shortcuts (like performing HTTP requests inside process()), the fork must adhere to strict interface definitions.The Mutable SoundSource Interface:The SoundSource class definition in src/soundsource.h must be augmented to support the concept of "Data Availability."C++// Source of Truth: src/soundsource.h modification for Mixxx-Kinetic
class SoundSource {
public:
    virtual ~SoundSource() {}

    // Essential for determining if a stream is "ready" for the engine to play without stalling.
    // Returns the percentage of the file currently available in the local cache.
    virtual double getCachedPercentage() const = 0; 
    
    // Returns a list of available byte ranges (e.g., for drawing the "downloaded" portion of the waveform).
    virtual QList<QPair<long, long>> getCachedRanges() const = 0;

    // The engine calls this to get audio. MUST return immediately.
    // If data is missing due to buffering, it should return 0 (silence) or a predictive filler,
    // and signal a buffering event to the UI, but NEVER block the thread.
    virtual unsigned read(unsigned long size, const SAMPLE * destination) = 0;
    
    // Seeks must be virtualized. If seeking into an unbuffered area,
    // the source initiates a high-priority download for that range via the StreamManager.
    virtual void seek(long filepos) = 0;
    
    // Returns the true length of the track, even if only partially downloaded.
    // This value must be retrieved from the API metadata (Content-Length or duration field)
    // before the file is fully available.
    virtual long length() const = 0;
};
This redefinition serves as a contract. Any implementation of SoundSource for streaming that contains a blocking socket.read() or http.get() call is explicitly forbidden by this doctrine.43. Component A: The Hook (API Interaction & Interception)This section documents the specific API endpoints, authentication flows, and data structures for Beatport and Tidal. These serve as the rigid specifications for the network layer. The "Hook" component is responsible for all interactions with the external world, sanitizing the chaotic data from the web before it touches the internal Mixxx structures.3.1. Beatport Link IntegrationBeatport’s ecosystem for third-party software is "Beatport Link." Unlike the consumer web store, this API is designed explicitly for streaming and subscription validation.3.1.1. Authentication: The OAuth GatekeeperBeatport utilizes OAuth 2.0 with the Authorization Code flow. This is the only authorized method for third-party applications to act on behalf of a user.Authorization Endpoint: https://api.beatport.com/v4/auth/o/authorize/Token Endpoint: https://api.beatport.com/v4/auth/o/token/Mechanism: The Mixxx fork must instantiate a local loopback web server (e.g., using QTcpServer on port 8888) to capture the redirect URI. Alternatively, registering a custom URI scheme mixxx:// via xdg-mime on EndeavourOS allows the system browser to callback to Mixxx.Essential Data Persistence: The access_token (short-lived, usually 1 hour) and refresh_token (long-lived) are critical. The refresh_token allows the session to persist across Mixxx restarts. This token must be stored in the system keyring (using libsecret or KWallet via QtKeychain) and never in plain text configuration files.Drift Prevention: The Hook class must implement an automatic token refresh interceptor. If any API call returns 401 Unauthorized, the interceptor must pause the request, use the refresh_token to get a new access_token, update the keychain, and retry the original request transparently.93.1.2. The Catalog API (Metadata)Before a track can be loaded, Mixxx must populate the TrackDAO. The Hook component maps the JSON response from Beatport directly to Mixxx's database columns.Track Metadata Endpoint: GET /v4/catalog/tracks/{id}Search Endpoint: GET /v4/catalog/searchResponse Structure & Mapping (Source of Truth):id (Integer) -> TrackDAO.remote_id (Crucial for linking streaming URL later).name (String) -> TrackDAO.title.artists (Array) -> TrackDAO.artist. The Hook must iterate this array and concatenate names (e.g., "Artist A, Artist B") as Mixxx uses a single string field for artists.bpm (Integer/Float) -> TrackDAO.bpm.key.name (String) -> TrackDAO.key. Beatport returns generic notation (e.g., "G#m"). The Hook must verify if the user prefers Camelot or OpenKey and translate this string using a KeyUtils class before storage.11images.medium.url (String) -> TrackDAO.cover_location. The Hook must trigger an asynchronous download of this image to ~/.cache/mixxx/covers/ and store the local path in the DAO, not the remote URL.33.1.3. The Stream API (The Payload)This is the most critical and volatile endpoint. It provides the location of the audio binary.Endpoint: GET /v4/catalog/tracks/{id}/streamResponse: A JSON object containing the stream_url. Note that this URL is often a temporary AWS CloudFront link signed with an expiration token.Stream Format: High-Efficiency Advanced Audio Coding (HE-AAC) or AAC-LC, encapsulated in an HLS (HTTP Live Streaming) container (.m3u8 playlist).13Drift Warning: The stream_url has a Time-To-Live (TTL). The StreamManager must handle 403 Forbidden errors on the stream URL by re-requesting the stream endpoint to get a fresh URL. It must not cache the URL indefinitely, only the content.Bitrate Switching: Beatport Link Pro offers 256kbps AAC. The API query parameters usually accept ?quality=high or similar flags. The Hook must check the user's subscription tier via the GET /v4/my/subscriptions endpoint to determine the maximum allowed bitrate.133.2. Tidal IntegrationTidal’s integration is more complex due to higher security requirements, stricter DRM (Widevine), and a different streaming protocol (MPEG-DASH).3.2.1. Authentication: Device FlowTidal often uses the Device Authorization Flow (RFC 8628), common for "headless" or TV applications. This is suitable for Mixxx as it avoids embedding a full browser engine just for login credential entry.Endpoint: https://auth.tidal.com/v1/oauth2/device_authorizationToken Endpoint: https://auth.tidal.com/v1/oauth2/tokenClient ID: Tidal does not publicly issue API keys to FOSS projects easily. To function, the fork may need to mimic a known client (e.g., "Tidal for Android" or a web player). This presents a stability risk if Tidal revokes the key. The architecture must allow the Client ID to be configurable via an advanced settings file (~/.config/mixxx/kinetic.conf) so users can supply their own keys if the default is revoked.153.2.2. The Playback Info EndpointThe "Source of Truth" for retrieving Tidal audio is the playbackinfopostpaywall endpoint.Endpoint: GET /v1/tracks/{id}/playbackinfopostpaywallRequired Parameters:audioquality: HI_RES (Master), LOSSLESS (FiFi), HIGH (320kbps), LOW (96kbps).playbackmode: STREAM.assetpresentation: FULL.Response Analysis (Source of Truth):MIME Type: application/dash+xml (MPEG-DASH) is the standard for HiFi/Master streams.Manifest: The JSON contains a field manifest which is a Base64 encoded XML string. This XML is the DASH Manifest (MPD).17Encryption: The response includes an encryptionType field. If this is set to WIDEVINE, the Hook must also extract the licenceUrl provided in the JSON to facilitate decryption.Drift Warning: Tidal has legacy endpoints (/streamUrl) that return direct URLs for lower quality streams. The architecture must implement a Strategy Pattern in the Hook to try the modern endpoint first and fallback to legacy endpoints if the schema changes.3.2.3. DRM: The Widevine ChallengeTidal streams (especially HiFi/Master/FLAC) are encrypted with Widevine DRM.The Constraint: libwidevinecdm.so is a proprietary binary blob. It cannot be linked directly into Mixxx (which is GPLv2+) due to license incompatibility.The Solution: The "Bridge" architecture (detailed in Section 5) must encapsulate the DRM handling in a separate, non-GPL process or rely on a browser-based fetcher logic that acts as a Content Decryption Module (CDM) host. On Linux, this involves extracting the libwidevinecdm.so from a Google Chrome or Chromium installation.164. Component B: The Bridge (Virtualization & FUSE)This is the core architectural innovation of the Mixxx-Kinetic fork. Rather than rewriting SoundSource to handle HTTP and HLS/DASH natively—which introduces massive complexity regarding buffering, seeking, and connection management into the audio thread—we implement a Userspace Filesystem (FUSE) layer. This creates a virtual directory (e.g., /run/user/1000/mixxx-stream/) where remote tracks appear as local files.4.1. Why FUSE?Compatibility: Mixxx’s engine already speaks "File" fluently. It knows open(), seek(), read(), and close(). FUSE satisfies this interface perfectly.Isolation: Network logic runs in the FUSE daemon process/thread, strictly separated from the real-time audio thread. If the network hangs, the FUSE read call blocks only the specific reader thread. We can isolate this reader thread from the EngineWorker using the SoundSourceProxy buffer, preventing the UI or Audio from freezing.Caching: FUSE allows us to implement sparse file caching transparently. We can tell Mixxx the file is 50MB (based on the Content-Length header), even if we've only downloaded the first 1MB. Mixxx sees a 50MB file and behaves accordingly.224.2. The FUSE Implementation: mixxx-fsWe define a new C++ component, mixxx-fs, which links against libfuse3. Ideally, this is implemented using a C++ wrapper like fuse-cpp or a custom lightweight wrapper to maintain C++ semantics.4.2.1. File Mapping LogicThe FUSE daemon creates a virtual file structure that maps to the Streaming APIs.Path Structure: /beatport/{track_id}.mp3 or /tidal/{track_id}.flac.getattr Call: When Mixxx calls stat() or getattr() to check the file size, mixxx-fs intercepts this. It performs a fast HEAD request (or uses cached metadata from the Hook) to get the file size. It returns a struct stat with the correct size immediately, creating the illusion of a complete, local file.4.2.2. The Sparse Cache StrategyTo handle non-linear access (e.g., a user jumping to the second breakdown of a track), we use a Sparse Cache.Backing Store: mixxx-fs maintains a real, sparse file on the physical disk (e.g., /var/cache/mixxx/partial/{uuid}.cache).The Interval Tree: In memory, mixxx-fs maintains an Interval Tree data structure (e.g., std::map<offset, length>) that tracks which chunks of the file have actually been downloaded.read Call: When Mixxx requests a read at offset X:The daemon queries the Interval Tree.Hit: If offset X is present in the cache, it reads from the backing disk file and returns data immediately.Miss: If offset X is missing, the daemon blocks the read request (which is safe, as it's the Proxy thread, not the Engine thread). It simultaneously triggers a high-priority HTTP Range Request (Range: bytes=X-(X+ChunkSize)) to the streaming provider. Once the data arrives, it writes it to the backing store, updates the Interval Tree, and unblocks the read.24Prefetching: Upon open(), mixxx-fs starts downloading the file sequentially from byte 0. If a seek() is detected (a read request far ahead of the current download pointer), the prefetcher creates a secondary download worker starting from the seek point, prioritizing the user's immediate need over the sequential fill.4.3. Handling DRM in FUSEFor Tidal (Widevine), the mixxx-fs cannot simply download the encrypted bytes and hand them to Mixxx, as Mixxx's FFmpeg decoders cannot handle Widevine encryption.Decryption on the Fly: The read() operation in FUSE must return decrypted PCM or standard container (e.g., MP4/AAC) data.The Decryption Proxy: mixxx-fs must spawn or communicate with a helper process (the CDM Host) that manages the libwidevinecdm.so.Data Flow:mixxx-fs downloads encrypted chunks.Chunks are passed to the CDM Host via shared memory (shm).CDM Host uses the Widevine blob to decrypt the chunk.Decrypted chunk is written back to the FUSE return buffer.Mixxx receives standard AAC/FLAC data.This architecture completely abstracts DRM away from the main Mixxx codebase, ensuring GPL compliance by keeping the proprietary blob interaction isolated in a user-controlled component.205. Component C: The Renderer (Audio Pipeline & Analysis)5.1. The Engine Worker InterfaceThe EngineWorker interacts with the audio data via the SoundSource. To ensure safety with the FUSE layer:Non-Blocking I/O: The SoundSourceProxy should open the FUSE file in non-blocking mode or use select/poll with a zero timeout.Silence Injection: If the FUSE layer cannot return data fast enough (buffer underrun), the SoundSourceProxy must return silence (zeroed buffer) and emit a buffer_underrun signal. The engine must not wait.Visual Feedback: The buffer_underrun signal is connected to the waveform display, causing it to dim or show a spinner, informing the DJ that the network is lagging, rather than leaving them wondering why the audio stopped.85.2. Analyzer Queue IntegrationMixxx needs to analyze the track to generate the waveform, BPM, and Beatgrid.The Problem: The standard AnalyzerQueue attempts to read the file from start to finish immediately. On a stream, this would force a full download of the file instantly, saturating the network bandwidth and competing with the playback stream.The Solution: The SoundSourceProxy must implement a throttling mechanism for the Analyzer. It identifies that the reader is the Analyzer thread (vs. the Playback thread). It serves data to the Analyzer only if that data is already in the Sparse Cache. If the Analyzer requests unbuffered data, the Proxy returns a specific "Not Ready" code, causing the Analyzer to yield and retry later. This ensures that analysis happens passively as the track downloads, filling in the waveform "behind" the download cursor.285.3. Caching & PersistenceTo ensure robustness on EndeavourOS:RAM Disk: For high-performance setups (16GB+ RAM), the manifest recommends mounting the sparse cache directory (/var/cache/mixxx/partial/) on tmpfs (RAM). This eliminates SSD write wear and reduces latency to near-zero for cached chunks.Persistent Locker: Tracks that are fully downloaded and verified (e.g., Beatport Link Pro Offline mode) should be moved from the temporary sparse cache to a permanent "Locker" directory (~/.mixxx/music/offline/). The TrackDAO location field must update from the FUSE path (/run/user/...) to the local path (/home/user/...) automatically. This provides true offline resilience.6. Component D: Analyzing Music Data (Metadata & Metrics)This layer acts as the brain, translating raw API data into the musical structures Mixxx understands.6.1. The Metadata NormalizerAPIs return data in varying formats. A MetadataNormalizer class is required to sanitize inputs.Key Notation: Beatport returns keys in musical notation (e.g., "F# min"). Tidal might return "Gb Minor". Mixxx uses a standardized internal representation (e.g., "6A"). The Normalizer must map these external strings to the user's preferred notation (Camelot, OpenKey, etc.) before insertion into TrackDAO.30Art: Remote URLs for cover art must be cached. TrackDAO typically stores a local path. The Normalizer must download the image to ~/.mixxx/cache/covers/ and update the database with this local path. Storing the remote URL directly is forbidden as it breaks cover art display in offline mode.36.2. Extended Database Schema (Source of Truth)The SQLite schema must be updated to support the Kinetic architecture.SQL-- Extended TrackDAO Schema for Streaming
ALTER TABLE library ADD COLUMN remote_source TEXT; -- 'beatport', 'tidal', 'filesystem'
ALTER TABLE library ADD COLUMN remote_id TEXT;     -- Unique ID from the API
ALTER TABLE library ADD COLUMN stream_url TEXT;    -- Cached stream URL (transient)
ALTER TABLE library ADD COLUMN stream_expires INTEGER; -- Epoch timestamp for URL expiry
ALTER TABLE library ADD COLUMN encryption_key_id TEXT; -- For DRM context
ALTER TABLE library ADD COLUMN offline_status INTEGER; -- 0=cloud, 1=cached, 2=permanent
This schema change allows Mixxx to query "All Beatport Tracks" (SELECT * FROM library WHERE remote_source='beatport') and manage cache eviction policies based on offline_status.17. Implementation Roadmap & EndeavourOS Integration7.1. The AUR Package: mixxx-kinetic-gitWe will distribute this fork via the Arch User Repository (AUR) to ensure seamless updates and dependency management.PKGBUILD Dependencies:libfuse3: For the virtualization layer.22qt6-webengine: For handling OAuth login flows properly.ffmpeg: For decoding HLS/AAC streams (ensure generic build, not restricted).32protobuf: For potential future API serialization.33widevine-aarch64 / widevine (AUR): Helper packages to pull the Widevine CDM shared library. The PKGBUILD will include a post_install message instructing the user to run the Widevine fetch script.207.2. System Tuning ProfileThe manifest recommends a systemd service or udev rule to tune the OS for streaming:Realtime Priority: Ensure the user is added to the realtime or audio group.Memlock: Increase ulimit -l to allow locking audio buffers in RAM, preventing paging during network activity.Network Tuning: Increase TCP buffer sizes (net.ipv4.tcp_rmem) via sysctl.d to handle high-bandwidth bursts from Tidal Master streams.PipeWire Config: Create a custom PipeWire profile (~/.config/pipewire/pipewire.conf.d/mixxx.conf) with a fixed quantum (buffer size) to minimize latency, as automatic quantum switching can cause dropouts when the FUSE layer engages.278. ConclusionThe "Kinetic Fork" doctrine represents a fundamental reimagining of Mixxx’s I/O architecture. It does not simply "add streaming"; it redefines the file. By treating the network as a virtual filesystem (FUSE) and strictly defining the API interaction layer through the "Hook" pattern, we decouple the inherent instability of the cloud from the rigid requirements of a real-time audio engine. This architecture respects the legacy of Mixxx—its reliability and precision—while forcefully adapting it to the reality of modern, access-based digital DJing. On EndeavourOS, this fork will not just be a port; it will be the reference implementation for high-performance, open-source streaming DJ software. The future is not just about having the music; it is about the reliability of the access.Table 1: Critical API Mapping for Streaming ServicesFeatureMixxx ComponentBeatport API EndpointTidal API EndpointAuthHook / OAuth Handler/v4/auth/o/authorize//v1/oauth2/device_authorizationMetadataHook / TrackDAO/v4/catalog/tracks/{id}/v1/tracks/{id}Stream URLHook / FUSE Daemon/v4/catalog/tracks/{id}/stream/v1/tracks/{id}/playbackinfopostpaywallFormatFUSE / FFmpegHLS (.m3u8) / AACMPEG-DASH (.mpd) / FLAC/AACDRMCDM HostNone (usually)Widevine (via libwidevinecdm.so)SearchLibrary Feature/v4/catalog/search/v1/searchTable 2: Proposed SoundSource Class HierarchyClassResponsibilityThread ContextSoundSourceAbstract InterfaceN/ASoundSourceProxyInterface Implementation, Status ReportingEngine/Main ThreadSoundSourceStreamData Fetching, Buffer ManagementStreamManager Threadmixxx-fs (External)FUSE Virtualization, Caching, DRMDaemon Process
